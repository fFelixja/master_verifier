package com.master_thesis.verifier;

import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.math.BigInteger;

import static org.junit.jupiter.api.Assertions.assertEquals;

class RSAThresholdTest {

    @Test
    void extendedEuclideanAlgorithm() {

        BigInteger a = BigInteger.valueOf(17);
        BigInteger b = BigInteger.valueOf(3);

        BigInteger[] eea = RSAThreshold.extendedEuclideanAlgorithm(a, b);

        BigInteger coefA = BigInteger.ONE.negate();
        BigInteger coefB = BigInteger.valueOf(6);
        BigInteger gcd = BigInteger.ONE;

        assertEquals(coefA, eea[0]);
        assertEquals(coefB, eea[1]);
        assertEquals(gcd, eea[2]);

        eea = RSAThreshold.extendedEuclideanAlgorithm(b, a);

        assertEquals(coefA, eea[1]);
        assertEquals(coefB, eea[0]);
        assertEquals(gcd, eea[2]);

    }

    @Test
    void extendedEuclideanAlgorithmLarger() {
        BigInteger a = BigInteger.valueOf(58568);
        BigInteger b = BigInteger.valueOf(7);

        BigInteger[] eea = RSAThreshold.extendedEuclideanAlgorithm(a, b);

        BigInteger coefA = BigInteger.valueOf(-1);
        BigInteger coefB = BigInteger.valueOf(8367);
        BigInteger gcd = BigInteger.ONE;

        assertEquals(coefA, eea[0]);
        assertEquals(coefB, eea[1]);
        assertEquals(gcd, eea[2]);

        eea = RSAThreshold.extendedEuclideanAlgorithm(b, a);

        assertEquals(coefA, eea[1]);
        assertEquals(coefB, eea[0]);
        assertEquals(gcd, eea[2]);
    }

    @Test
    void extendedEuclideanAlgorithmNegative() {
        BigInteger a = BigInteger.valueOf(2 * -168548);
        BigInteger b = BigInteger.valueOf(7);

        BigInteger[] eea = RSAThreshold.extendedEuclideanAlgorithm(a, b);

        BigInteger coefA = BigInteger.valueOf(2);
        BigInteger coefB = BigInteger.valueOf(-96313);
        BigInteger gcd = BigInteger.ONE;

        assertEquals(coefA, eea[0]);
        assertEquals(coefB, eea[1]);
        assertEquals(gcd, eea[2]);

        eea = RSAThreshold.extendedEuclideanAlgorithm(b, a);

        assertEquals(coefA, eea[1]);
        assertEquals(coefB, eea[0]);
        assertEquals(gcd, eea[2]);
    }

    @Test
    void verifierSchemeTest() {
        // BigInteger pk, BigInteger clientProof, BigInteger[] serverProofs, BigInteger rsaN, double determinant
        // The clientProof we define should be equal res.modPow(pk, rsaN)

        BigInteger det = BigInteger.valueOf(126);
        // Co-prime with det and N'
        BigInteger pk = BigInteger.valueOf(5);
        // Inverse of pk in N'
        BigInteger sk = BigInteger.valueOf(361);
        // Any value in N
        BigInteger clientProof = BigInteger.valueOf(30);
        // p*q where p,q are safe primes generated by the safe primes p', q'
        BigInteger rsaN = BigInteger.valueOf(1909);


        BigInteger[] skShares = new BigInteger[]{BigInteger.valueOf(4380), BigInteger.valueOf(1179)};
        BigInteger[] cValues = new BigInteger[]{BigInteger.valueOf(12), BigInteger.valueOf(-6)};

        testVerifierScheme(det, sk, cValues, skShares, clientProof, rsaN, pk);

    }

    @Test
    void verifierSchemeTestLargePublicKey() {
        // BigInteger pk, BigInteger clientProof, BigInteger[] serverProofs, BigInteger rsaN, double determinant
        // The clientProof we define should be equal res.modPow(pk, rsaN)

        BigInteger det = BigInteger.valueOf(15319);
        // Co-prime with det and N'
        BigInteger pk = BigInteger.valueOf(503);
        // Inverse of pk in N'
        BigInteger sk = BigInteger.valueOf(425);
        // Any value in N
        BigInteger clientProof = BigInteger.valueOf(43);
        // p*q where p,q are safe primes generated by the safe primes p', q'
        BigInteger rsaN = BigInteger.valueOf(1909);

        BigInteger[] skShares = new BigInteger[]{BigInteger.valueOf(120628), BigInteger.valueOf(32445)};
        BigInteger[] cValues = new BigInteger[]{BigInteger.valueOf(65), BigInteger.valueOf(-41)};

        testVerifierScheme(det, sk, cValues, skShares, clientProof, rsaN, pk);
    }

    @Test
    @Disabled
    void testFistFailedGeneration() {
        // BigInteger pk, BigInteger clientProof, BigInteger[] serverProofs, BigInteger rsaN, double determinant
        // The clientProof we define should be equal res.modPow(pk, rsaN)

        BigInteger det = BigInteger.valueOf(251577);
        // Co-prime with det and N'
        BigInteger pk = BigInteger.valueOf(2269);
        // Inverse of pk in N'
        BigInteger sk = BigInteger.valueOf(290);
        // Any value in N
        BigInteger clientProof = BigInteger.valueOf(43);
        // p*q where p,q are safe primes generated by the safe primes p', q'
        BigInteger rsaN = BigInteger.valueOf(1909);

        BigInteger[] skShares = new BigInteger[]{BigInteger.valueOf(84856), BigInteger.valueOf(25053)};
        BigInteger[] cValues = new BigInteger[]{BigInteger.valueOf(65), BigInteger.valueOf(-41)};

        testVerifierScheme(det, sk, cValues, skShares, clientProof, rsaN, pk);
    }

    private void testVerifierScheme(BigInteger det, BigInteger sk, BigInteger[] cValues, BigInteger[] wValues, BigInteger clientProof, BigInteger rsaN, BigInteger pk) {
        BigInteger two = BigInteger.TWO;
        // Check that SUM: Cij*wj*2 is correct
        BigInteger determinantKeyTwo = det.multiply(sk).multiply(two);
        BigInteger sigmaRoof = BigInteger.ZERO;
        for (int i = 0; i < cValues.length; i++) {
            sigmaRoof = sigmaRoof.add(cValues[i].multiply(wValues[i]).multiply(two));
        }
        assertEquals(determinantKeyTwo, sigmaRoof, " SUM: Cij*wj*2 is correct");

        // Check that PROD: sigma_j == tau^determinantKeyTwo
        sigmaRoof = BigInteger.ONE;
        for (int i = 0; i < cValues.length; i++) {
            sigmaRoof = sigmaRoof.multiply(clientProof.modPow(cValues[i].multiply(wValues[i]).multiply(two), rsaN)).mod(rsaN);
        }
        assertEquals(clientProof.modPow(determinantKeyTwo, rsaN), sigmaRoof, " PROD: sigma_j == tau^determinantKeyTwo");

        BigInteger sigmaRoofNoKeys = sigmaRoof.modPow(pk, rsaN);
        assertEquals(clientProof.modPow(two.multiply(det), rsaN), sigmaRoofNoKeys, "publicKey secretKey removal");

        BigInteger[] eea = RSAThreshold.extendedEuclideanAlgorithm(det.multiply(two), pk);
        BigInteger alpha = eea[0];
        BigInteger beta = eea[1];
        BigInteger tauAlpha = sigmaRoof.modPow(alpha, rsaN);
        BigInteger tauBeta = clientProof.modPow(beta, rsaN);

        BigInteger sigma = tauAlpha.multiply(tauBeta).mod(rsaN).modPow(pk, rsaN);

        assertEquals(clientProof, sigma, "final evaluation");
    }


}